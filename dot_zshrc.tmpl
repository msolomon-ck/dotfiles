# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

export PATH="$HOME/.local/bin:$PATH"
export PATH="$HOME/.rd/bin:$PATH"

# Path to your Oh My Zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Set name of the theme to load --- if set to "random", it will
# load a random theme each time Oh My Zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME="robbyrussell"

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in $ZSH/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE="true"

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE="true"

# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
# HIST_STAMPS="mm/dd/yyyy"

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git zsh-autosuggestions zsh-syntax-highlighting)

source $ZSH/oh-my-zsh.sh

# User configuration

# export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='nvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch $(uname -m)"

# Set personal aliases, overriding those provided by Oh My Zsh libs,
# plugins, and themes. Aliases can be placed here, though Oh My Zsh
# users are encouraged to define aliases within a top-level file in
# the $ZSH_CUSTOM folder, with .zsh extension. Examples:
# - $ZSH_CUSTOM/aliases.zsh
# - $ZSH_CUSTOM/macos.zsh
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig="mate ~/.zshrc"
# alias ohmyzsh="mate ~/.oh-my-zsh"

alias c=chezmoi

# Configure tmux
# if [ -z "$TMUX" ] && [ "$INTEGRATED_TERMINAL" != "true" ]; then
#    tmux attach -t main || tmux new -s main
# fi

# Configure FZF
source <(fzf --zsh)

# CTRL-Y to copy the command into clipboard using pbcopy
export FZF_CTRL_R_OPTS="
  --bind 'ctrl-y:execute-silent(echo -n {2..} | pbcopy)+abort'
  --color header:italic
  --header 'Press CTRL-Y to copy command into clipboard'"

# Preview file content using bat (https://github.com/sharkdp/bat)
export FZF_CTRL_T_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'bat -n --color=always {}'
  --bind 'ctrl-/:change-preview-window(down|hidden|)'"

# Print tree structure in the preview window
export FZF_ALT_C_OPTS="
  --walker-skip .git,node_modules,target
  --preview 'tree -C {}'"


# Helpful funcitons
go() {
  local dir
  dir=$(find ~/dev -mindepth 1 -maxdepth 1 -type d | fzf --height=40% --reverse --prompt="~/dev: ")
  if [[ -n "$dir" ]]; then
    cd "$dir" || echo "Failed to cd into $dir"
  fi
}

# Use fzf to select and checkout a git branch, sorted by recent activity
gbc() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local branch
  branch=$(git for-each-ref --format='%(refname:short) %(committerdate:relative)' --sort=-committerdate refs/heads/ | \
    fzf --height=40% --reverse --prompt="Checkout branch: " --preview="git log --oneline --graph --color=always {1}" | \
    awk '{print $1}')
  
  if [[ -n "$branch" ]]; then
    git checkout "$branch"
  fi
}

# open the current directory in intellij
idea() {
  open -na "IntelliJ IDEA.app" --args "$@"
}

# Open current git branch in a new browser window using gh cli
ghb() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local branch=$(git branch --show-current)
  if [[ -z "$branch" ]]; then
    echo "Error: Could not determine current branch"
    return 1
  fi
  
  echo "Opening branch '$branch' in new window..."
  gh browse --branch "$branch"
}

# Git stash management with fzf - list, preview, apply, or drop stashes
gsf() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local stashes
  stashes=$(git stash list --format="%gd: %gs (%cr)" 2>/dev/null)
  
  if [[ -z "$stashes" ]]; then
    echo "No stashes found"
    return 0
  fi
  
  local selected
  selected=$(echo "$stashes" | \
    fzf --height=40% --reverse --prompt="Stash action: " \
        --preview="git stash show -p {1} --color=always" \
        --header="Enter=apply, Ctrl-D=drop, Ctrl-P=pop, Esc=cancel" \
        --bind="ctrl-d:execute(git stash drop {1})+reload(git stash list --format='%gd: %gs (%cr)')" \
        --bind="ctrl-p:accept" \
        --expect="ctrl-p")
  
  if [[ -n "$selected" ]]; then
    local key=$(echo "$selected" | head -1)
    local stash=$(echo "$selected" | tail -1 | awk '{print $1}')
    
    case "$key" in
      "ctrl-p")
        git stash pop "$stash"
        ;;
      *)
        git stash apply "$stash"
        ;;
    esac
  fi
}

# Delete tag locally and remotely, then create and push a new one
tag() {
  if [[ -z "$1" ]]; then
    echo "Usage: tag <tag-name>"
    return 1
  fi
  
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    return 1
  fi
  
  local tag_name="$1"
  
  echo "Processing tag: $tag_name"
  
  # Delete tag locally if it exists
  if git tag -l | grep -q "^${tag_name}$"; then
    echo "Deleting local tag: $tag_name"
    git tag -d "$tag_name"
  else
    echo "Local tag '$tag_name' does not exist"
  fi
  
  # Delete tag remotely if it exists
  echo "Attempting to delete remote tag: $tag_name"
  git push origin --delete "$tag_name" 2>/dev/null || echo "Remote tag '$tag_name' does not exist or already deleted"
  
  # Create new tag locally
  echo "Creating new local tag: $tag_name"
  git tag "$tag_name"
  
  # Push tag to remote
  echo "Pushing tag to remote: $tag_name"
  git push origin "$tag_name"
  
  echo "Tag '$tag_name' has been successfully recreated and pushed"
  
  # Extract repository name and print CCI workflows link
  local remote_url=$(git remote get-url origin 2>/dev/null)
  if [[ -n "$remote_url" ]]; then
    local repo_name=$(echo "$remote_url" | sed -E 's/.*[\/:]([^\/]+)\.git$/\1/')
    if [[ -n "$repo_name" ]]; then
      echo ""
      echo "CCI Workflows: https://app.gcp-circleci.build.corp.creditkarma.com/pipelines/github/ck-private/$repo_name"
    fi
  fi
}

function ds() {
     docker stop $(docker ps -a -q)
}

# Environment Exports

{{ if .isWork }}
export GH_TOKEN="{{ onepasswordRead "op://Employee/ZSH GitHub Token/password" }}"
{{ else }}export GH_TOKEN="{{ onepasswordRead "op://Personal/ZSH GitHub Token/password" }}"
{{ end  }}

export PATH="$HOME/.jenv/bin:$PATH"
eval "$(jenv init -)"
jenv enable-plugin export

